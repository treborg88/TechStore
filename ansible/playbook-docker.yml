# =============================================================================
# Ansible Playbook — TechStore (Docker Compose Mode)
# =============================================================================
# Provisions a fresh Ubuntu VM and deploys the full stack with Docker Compose:
#   PostgreSQL + Express backend + Vite/React frontend + Nginx proxy
#
# Usage:
#   # Full setup + deploy (fresh VM)
#   ansible-playbook -i ansible/inventory.yml ansible/playbook-docker.yml --limit test
#
#   # Redeploy only (Docker already installed)
#   ansible-playbook -i ansible/inventory.yml ansible/playbook-docker.yml --tags deploy --limit test
#
#   # Update & rebuild specific service
#   ansible-playbook -i ansible/inventory.yml ansible/playbook-docker.yml --tags update --limit test
#
# Prerequisites:
#   pip install ansible    (local machine)
#   SSH key access to the target server
# =============================================================================

- name: Deploy TechStore (Docker Compose)
  hosts: docker
  become: true
  vars_files:
    - vars/main.yml

  tasks:

    # ═══════════════════════════════════════════════════════════════════════
    # SETUP — Install Docker Engine + Compose plugin
    # ═══════════════════════════════════════════════════════════════════════

    # ── Wait for cloud-init to finish (fresh VMs) ─────────
    - name: Wait for cloud-init to finish
      tags: [setup]
      ansible.builtin.command: cloud-init status --wait
      changed_when: false
      failed_when: false
      timeout: 300

    # ── System packages ───────────────────────────────────
    - name: Update apt cache
      tags: [setup]
      ansible.builtin.apt:
        update_cache: true
        cache_valid_time: 3600

    - name: Install base packages
      tags: [setup]
      ansible.builtin.apt:
        name:
          - git
          - curl
          - ca-certificates
          - gnupg
        state: present

    # ── Docker Engine (official script) ────────────────────
    - name: Check if Docker is installed
      tags: [setup, docker]
      ansible.builtin.command: docker --version
      register: docker_check
      changed_when: false
      failed_when: false

    - name: Install Docker Engine
      tags: [setup, docker]
      ansible.builtin.shell: curl -fsSL https://get.docker.com | sh
      when: docker_check.rc != 0

    - name: Add deploy user to docker group
      tags: [setup, docker]
      ansible.builtin.user:
        name: "{{ deploy_user }}"
        groups: docker
        append: true

    - name: Ensure Docker service is running
      tags: [setup, docker]
      ansible.builtin.service:
        name: docker
        state: started
        enabled: true

    # ── Verify Docker Compose plugin ──────────────────────
    - name: Verify Docker Compose plugin
      tags: [setup, docker]
      ansible.builtin.command: docker compose version
      changed_when: false

    # ── Open firewall ports (iptables) ────────────────────
    - name: Open HTTP port 80 in iptables
      tags: [setup, firewall]
      ansible.builtin.iptables:
        chain: INPUT
        protocol: tcp
        destination_port: "80"
        jump: ACCEPT
        action: insert
        rule_num: "5"
        comment: "TechStore HTTP"

    - name: Open HTTPS port 443 in iptables
      tags: [setup, firewall]
      ansible.builtin.iptables:
        chain: INPUT
        protocol: tcp
        destination_port: "443"
        jump: ACCEPT
        action: insert
        rule_num: "6"
        comment: "TechStore HTTPS"

    - name: Install iptables-persistent for rule persistence
      tags: [setup, firewall]
      ansible.builtin.apt:
        name: iptables-persistent
        state: present
      environment:
        DEBIAN_FRONTEND: noninteractive

    - name: Save iptables rules
      tags: [setup, firewall]
      ansible.builtin.command: netfilter-persistent save
      changed_when: true

    # ═══════════════════════════════════════════════════════════════════════
    # CLEANUP — Reclaim disk space (saves ~5GB on fresh OCI VMs)
    # ═══════════════════════════════════════════════════════════════════════

    # — Trim systemd journal to 100MB (default keeps ALL logs forever)
    - name: Limit systemd journal to 100MB
      tags: [setup, cleanup]
      ansible.builtin.command: journalctl --vacuum-size=100M
      changed_when: true

    # — Remove unused snap packages (LXD ~730MB, unused on Docker deploys)
    - name: List installed snaps
      tags: [setup, cleanup]
      ansible.builtin.command: snap list --all
      register: snap_list
      changed_when: false
      failed_when: false

    - name: Remove LXD snap (unused, ~730MB)
      tags: [setup, cleanup]
      ansible.builtin.command: snap remove --purge lxd
      when: "'lxd' in snap_list.stdout"
      failed_when: false
      changed_when: true

    - name: Remove core18 snap (legacy, ~314MB)
      tags: [setup, cleanup]
      ansible.builtin.command: snap remove --purge core18
      when: "'core18' in snap_list.stdout"
      failed_when: false
      changed_when: true

    # — Clear apt cache (~280MB)
    - name: Clean apt cache
      tags: [setup, cleanup]
      ansible.builtin.apt:
        autoclean: true

    - name: Remove unused apt packages
      tags: [setup, cleanup]
      ansible.builtin.apt:
        autoremove: true
        purge: true

    # — Clear failed login logs (brute-force attempts, ~130MB)
    - name: Truncate btmp logs (failed SSH login attempts)
      tags: [setup, cleanup]
      ansible.builtin.shell: "truncate -s 0 /var/log/btmp /var/log/btmp.1 2>/dev/null || true"
      changed_when: true

    # — Configure journal size limit permanently (prevent regrowth)
    - name: Set permanent journal size limit (100MB)
      tags: [setup, cleanup]
      ansible.builtin.lineinfile:
        path: /etc/systemd/journald.conf
        regexp: '^#?SystemMaxUse='
        line: 'SystemMaxUse=100M'
      notify: restart journald

    # ═══════════════════════════════════════════════════════════════════════
    # SSL — Cloudflare Origin Certificate (when ssl_mode == 'full_strict')
    # ═══════════════════════════════════════════════════════════════════════

    - name: Create SSL certificate directory
      tags: [setup, deploy, ssl]
      ansible.builtin.file:
        path: "{{ ssl_cert_dir }}"
        state: directory
        owner: root
        group: root
        mode: "0700"
      when: ssl_mode | default('flexible') == 'full_strict'

    - name: Deploy Origin Certificate (wildcard *.eonsclover.com)
      tags: [setup, deploy, ssl]
      ansible.builtin.copy:
        src: "{{ cf_origin_cert_file }}"
        dest: "{{ ssl_cert_path }}"
        owner: root
        group: root
        mode: "0644"
      when: ssl_mode | default('flexible') == 'full_strict' and cf_origin_cert_file is defined

    - name: Deploy Origin Certificate Key
      tags: [setup, deploy, ssl]
      ansible.builtin.copy:
        src: "{{ cf_origin_key_file }}"
        dest: "{{ ssl_key_path }}"
        owner: root
        group: root
        mode: "0600"
      when: ssl_mode | default('flexible') == 'full_strict' and cf_origin_key_file is defined

    - name: Check if SSL certs already exist on server
      tags: [deploy, ssl]
      ansible.builtin.stat:
        path: "{{ ssl_cert_path }}"
      register: ssl_cert_exists
      when: ssl_mode | default('flexible') == 'full_strict'

    - name: Validate SSL certificate
      tags: [deploy, ssl]
      ansible.builtin.command: openssl x509 -in {{ ssl_cert_path }} -noout -subject
      changed_when: false
      when: ssl_mode | default('flexible') == 'full_strict' and (ssl_cert_exists.stat.exists | default(false))

    # — Fail early if SSL is required but no certs found
    - name: Abort if SSL certs missing for full_strict mode
      tags: [deploy, ssl]
      ansible.builtin.fail:
        msg: |
          SSL mode is 'full_strict' but no certificate found at {{ ssl_cert_path }}.
          Either provide cert files via the orchestrator wizard (SSL Cert File / SSL Key File),
          or manually copy them to the server:
            scp cert.pem ubuntu@{{ ansible_host }}:{{ ssl_cert_path }}
            scp cert.key ubuntu@{{ ansible_host }}:{{ ssl_key_path }}
      when: ssl_mode | default('flexible') == 'full_strict' and not (ssl_cert_exists.stat.exists | default(false))

    # ═══════════════════════════════════════════════════════════════════════
    # DEPLOY — Clone repo, generate .env, docker compose up
    # ═══════════════════════════════════════════════════════════════════════

    # ── Clone / pull repository ───────────────────────────
    - name: Clone or update repository
      tags: [deploy, update]
      become_user: "{{ deploy_user }}"
      ansible.builtin.git:
        repo: "{{ app_repo }}"
        dest: "{{ app_path }}"
        version: "{{ app_branch }}"
        force: true
        accept_hostkey: true

    # ── Create logs directory ─────────────────────────────
    - name: Ensure logs directory exists
      tags: [deploy]
      ansible.builtin.file:
        path: "{{ app_path }}/logs"
        state: directory
        owner: "{{ deploy_user }}"
        group: "{{ deploy_group }}"
        mode: "0755"

    # ── Generate .env (only on first deploy) ─────────────────
    - name: Check if backend .env exists
      tags: [deploy]
      ansible.builtin.stat:
        path: "{{ app_path }}/backend/.env"
      register: env_file

    - name: Generate JWT_SECRET for new deployment
      tags: [deploy]
      ansible.builtin.command: openssl rand -hex 32
      register: jwt_secret_generated
      when: not env_file.stat.exists
      changed_when: false

    - name: Deploy backend .env (first deploy only)
      tags: [deploy]
      ansible.builtin.template:
        src: templates/backend.env.j2
        dest: "{{ app_path }}/backend/.env"
        owner: "{{ deploy_user }}"
        group: "{{ deploy_group }}"
        mode: "0600"
      vars:
        jwt_secret: "{{ jwt_secret_generated.stdout }}"
      when: not env_file.stat.exists

    # ── Render Nginx proxy config from template ─────────────
    # Overwrites the static docker/nginx-proxy.conf with the
    # Jinja2 version (adds SSL when ssl_mode == 'full_strict').
    - name: Deploy Nginx proxy config (Docker)
      tags: [deploy, update, ssl]
      ansible.builtin.template:
        src: templates/nginx-docker-proxy.conf.j2
        dest: "{{ app_path }}/docker/nginx-proxy.conf"
        owner: "{{ deploy_user }}"
        group: "{{ deploy_group }}"
        mode: "0644"

    # ── Patch docker-compose.yml for SSL port + cert mount ─
    # lineinfile with insertafter is idempotent (no duplicates).
    - name: Expose port 443 on proxy container
      tags: [deploy, update, ssl]
      ansible.builtin.lineinfile:
        path: "{{ app_path }}/docker-compose.yml"
        insertafter: '"80:80"'
        line: '      - "443:443"'
        state: present
      when: ssl_mode | default('flexible') == 'full_strict'

    - name: Mount SSL certs volume into proxy container
      tags: [deploy, update, ssl]
      ansible.builtin.lineinfile:
        path: "{{ app_path }}/docker-compose.yml"
        insertafter: 'nginx-proxy.conf:/etc/nginx/conf.d/default.conf:ro'
        line: '      - /etc/ssl/cloudflare:/etc/ssl/cloudflare:ro'
        state: present
      when: ssl_mode | default('flexible') == 'full_strict'

    # ── Build & start containers ──────────────────────────
    - name: Build and start Docker Compose stack
      tags: [deploy, update]
      become_user: "{{ deploy_user }}"
      ansible.builtin.command: docker compose up --build -d
      args:
        chdir: "{{ app_path }}"
      changed_when: true

    # ═══════════════════════════════════════════════════════════════════════
    # VERIFY — Wait for all services to be healthy
    # ═══════════════════════════════════════════════════════════════════════

    - name: Wait for containers to start
      tags: [deploy, update, verify]
      ansible.builtin.pause:
        seconds: 15

    - name: Check Docker container status
      tags: [deploy, update, verify]
      become_user: "{{ deploy_user }}"
      ansible.builtin.command: docker compose ps --format json
      args:
        chdir: "{{ app_path }}"
      register: compose_status
      changed_when: false

    - name: Display container status
      tags: [deploy, update, verify]
      ansible.builtin.debug:
        msg: "{{ compose_status.stdout }}"

    # ── Health check: backend API responding ──────────────
    - name: Wait for backend API to respond
      tags: [deploy, update, verify]
      ansible.builtin.uri:
        url: "http://127.0.0.1:{{ backend_port }}/api/products"
        method: GET
        status_code: [200]
      register: api_check
      retries: 10
      delay: 5
      until: api_check.status == 200

    # ── Health check: frontend/proxy responding ───────────
    - name: Wait for proxy to respond (HTTP)
      tags: [deploy, update, verify]
      ansible.builtin.uri:
        url: "http://127.0.0.1:80/"
        method: GET
        status_code: [200, 301]
        follow_redirects: none
      register: frontend_check
      retries: 10
      delay: 5
      until: frontend_check.status | default(-1) in [200, 301]
      ignore_errors: true

    # — Show proxy logs if health check failed (for debugging)
    - name: Show proxy container logs (debug)
      tags: [deploy, update, verify]
      become_user: "{{ deploy_user }}"
      ansible.builtin.command: docker compose logs --tail 30 proxy
      args:
        chdir: "{{ app_path }}"
      register: proxy_logs
      changed_when: false
      when: frontend_check is failed

    - name: Display proxy logs
      tags: [deploy, update, verify]
      ansible.builtin.debug:
        msg: "{{ proxy_logs.stdout_lines | default([]) }}"
      when: frontend_check is failed

    - name: Fail if proxy not responding
      tags: [deploy, update, verify]
      ansible.builtin.fail:
        msg: "Proxy container not responding on port 80. Check logs above."
      when: frontend_check is failed

    - name: Wait for HTTPS to respond
      tags: [deploy, update, verify]
      ansible.builtin.uri:
        url: "https://127.0.0.1:443/"
        method: GET
        status_code: [200]
        validate_certs: false
      register: https_check
      retries: 10
      delay: 5
      until: https_check.status == 200
      when: ssl_mode | default('flexible') == 'full_strict'

    # ── Display result ────────────────────────────────────
    - name: Deployment summary
      tags: [deploy, update, verify]
      ansible.builtin.debug:
        msg: |
          ✅ {{ app_name }} deployed successfully (Docker mode)!

          App:        {{ 'https' if ssl_mode | default('flexible') == 'full_strict' else 'http' }}://{{ domain | default(ansible_host) }}
          API:        {{ 'https' if ssl_mode | default('flexible') == 'full_strict' else 'http' }}://{{ domain | default(ansible_host) }}/api/products
          SSL:        {{ ssl_mode | default('flexible') }}
          Containers: 4 (database, backend, frontend, proxy)

          Useful commands (SSH into server):
            docker compose ps
            docker compose logs -f backend
            docker compose restart backend
            docker compose down && docker compose up --build -d

    # ═══════════════════════════════════════════════════════════════════════
    # MAINTENANCE TAGS — Granular operations
    # ═══════════════════════════════════════════════════════════════════════

    # ── Stop all containers ───────────────────────────────
    - name: Stop Docker Compose stack
      tags: [never, stop]
      become_user: "{{ deploy_user }}"
      ansible.builtin.command: docker compose down
      args:
        chdir: "{{ app_path }}"
      changed_when: true

    # ── View logs ─────────────────────────────────────────
    - name: Show recent backend logs
      tags: [never, logs]
      become_user: "{{ deploy_user }}"
      ansible.builtin.command: docker compose logs --tail 50 backend
      args:
        chdir: "{{ app_path }}"
      register: backend_logs
      changed_when: false

    - name: Display backend logs
      tags: [never, logs]
      ansible.builtin.debug:
        msg: "{{ backend_logs.stdout_lines }}"

    # ── Cleanup: prune unused Docker resources ────────────
    - name: Prune unused Docker images and volumes
      tags: [never, cleanup]
      ansible.builtin.command: docker system prune -af --volumes
      changed_when: true

    # ── Full destroy: containers + volumes + data ─────────
    - name: Destroy stack (containers + volumes)
      tags: [never, destroy]
      become_user: "{{ deploy_user }}"
      ansible.builtin.command: docker compose down -v
      args:
        chdir: "{{ app_path }}"
      changed_when: true

  # ═══════════════════════════════════════════════════════════════════════
  # HANDLERS
  # ═══════════════════════════════════════════════════════════════════════
  handlers:
    - name: restart journald
      ansible.builtin.service:
        name: systemd-journald
        state: restarted
